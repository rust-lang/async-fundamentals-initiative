<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Phase 1 - async fn fundamentals initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../stakeholders.html">üë™ Stakeholders</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../stakeholders/2021-nov.html">2021-Nov</a></li></ol></li><li class="chapter-item "><a href="../roadmap.html">üõ£ Roadmap</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../roadmap/static_async_trait.html">üí¨ Static async trait</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../roadmap/static_async_trait_mvp.html">MVP: Static async fn in traits</a></li></ol></li><li class="chapter-item "><a href="../roadmap/impl_trait_in_traits.html">üí¨ impl Trait in traits</a></li><li class="chapter-item "><a href="../roadmap/dyn_async_trait.html">üí¨ Dyn async trait</a></li><li class="chapter-item "><a href="../roadmap/dyn_trait.html">üí§ Dyn trait</a></li><li class="chapter-item "><a href="../roadmap/async_drop.html">üí§ Async drop</a></li><li class="chapter-item "><a href="../roadmap/async_closures.html">üí§ Async closures</a></li></ol></li><li class="chapter-item "><a href="../evaluation.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/executor-styles.html">Executor styles</a></li><li class="chapter-item "><a href="../evaluation/scenarios.html">Reference scenarios</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/scenarios/background-logging.html">Background logging</a></li><li class="chapter-item "><a href="../evaluation/scenarios/implementing-async-read.html">Implementing AsyncRead</a></li></ol></li><li class="chapter-item "><a href="../evaluation/challenges.html">Challenges</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/challenges/bounding_futures.html">Bounding futures</a></li><li class="chapter-item "><a href="../evaluation/challenges/naming_futures.html">Naming futures</a></li><li class="chapter-item "><a href="../evaluation/challenges/dyn_traits.html">Dyn traits</a></li><li class="chapter-item "><a href="../evaluation/challenges/bounding_async_drop.html">Bounding async drop</a></li><li class="chapter-item "><a href="../evaluation/challenges/guaranteeing_async_drop.html">Guaranteeing async drop</a></li><li class="chapter-item "><a href="../evaluation/challenges/implicit_await_with_async_drop.html">Implicit await with async drop</a></li></ol></li><li class="chapter-item "><a href="../evaluation/design.html">Design documents</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/design/implied_send.html">Implied Send</a></li><li class="chapter-item "><a href="../evaluation/design/trait_multiplication.html">Trait multiplication</a></li><li class="chapter-item "><a href="../evaluation/design/inline_async_fn.html">Inline async fn</a></li><li class="chapter-item "><a href="../evaluation/design/custom_dyn_impls.html">Custom dyn impls</a></li><li class="chapter-item "><a href="../evaluation/design/auto_traits_consider_async_drop.html">Auto traits consider AsyncDrop</a></li><li class="chapter-item "><a href="../evaluation/design/simple_names.html">Simple names</a></li><li class="chapter-item "><a href="../evaluation/design/bound_items.html">Bound items</a></li><li class="chapter-item "><a href="../evaluation/design/with_clauses.html">With clauses</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../explainer/phase_1.html" class="active">Phase 1</a></li><li class="chapter-item "><a href="../explainer/phase_1_narrative.html">Phase 1 narrative</a></li><li class="chapter-item "><a href="../explainer/phase_2.html">Phase 2</a></li><li class="chapter-item "><a href="../explainer/phase_3.html">Phase 3</a></li></ol></li><li class="chapter-item "><a href="../RFC.html">‚ú® RFC</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../RFC/static_async_fn_in_traits.html">Static async fn in traits</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">async fn fundamentals initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/async-fundamentals-initiative" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/async-fundamentals-initiative/edit/master/./explainer/phase_1.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="async-fundamentals-stage-1-explainer"><a class="header" href="#async-fundamentals-stage-1-explainer">Async Fundamentals Stage 1 Explainer</a></h1>
<p>This document describes <strong>Stage 1</strong> of the &quot;Async Fundamentals&quot; plans. Our eventual goal is to make it so that, in short, wherever you write <code>fn</code>, you can also write <code>async fn</code> and have things work as transparently as possible. This includes in traits, even special traits like <code>Drop</code>.</p>
<p>Now that I've got you all excited, let me bring you back down to earth: That is our goal, but Stage 1 does not achieve it. However, we do believe that Stage 1 does enable async functions in traits in such a way that everything is possible, though it may not be easy.</p>
<p>The hope is that by having a stage 1 where stable Rust exposes the core functionality needed for async traits, we can get more data about how async traits will be used in practice. That can guide us as we try to resolve some of the (rather sticky) design questions that block making things more ergonomic. =)</p>
<h2 id="review-how-async-fn-works"><a class="header" href="#review-how-async-fn-works">Review: how async fn works</a></h2>
<p>When you write an async function in Rust:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn test(x: &amp;u32) -&gt; u32 {
    *x
}
<span class="boring">}
</span></code></pre></pre>
<p>This is actually shorthand for a function that returns an <code>impl Future</code> and which captures all of its arguments. The body of this function is an <code>async move</code> block, which simply creates and returns a future:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn test&lt;'x&gt;(x: &amp;'x u32) -&gt; impl Future&lt;Output = u32&gt; + 'x {
    async move {
        *x
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>await</code> operation can be performed on any value that implements <code>Future</code>. It causes the <code>async fn</code> to execute the future's &quot;poll&quot; function to see if it's value is ready. If not, then it suspends the current frame until it is re-invoked.</p>
<h2 id="async-fn-in-traits"><a class="header" href="#async-fn-in-traits">Async fn in traits</a></h2>
<p>Writing an async function in a trait desugars in just the same way as an async function elsewhere. Hence this trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HttpRequestProvider {
    async fn request(&amp;mut self, request: Request) -&gt; Response;
}
<span class="boring">}
</span></code></pre></pre>
<p>becomes:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HttpRequestProvider {
    fn request&lt;'a&gt;(&amp;'a mut self, request: Request) -&gt; impl Future&lt;Output = Response&gt; + 'a;
}
<span class="boring">}
</span></code></pre></pre>
<p>On stable Rust today, <code>impl Trait</code> is not permitted in &quot;return position&quot; within a trait, but we plan to allow it. It will desugar to a function that returns an associated type with the same name as the method itself:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait HttpRequestProvider {
    type request&lt;'a&gt;: Future&lt;Output = Response&gt; + 'a;
    fn request&lt;'a&gt;(&amp;'a mut self, request: Request) -&gt; Self::request&lt;'a&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Calling <code>t.request(...)</code> thus returns a value of type <code>T::request&lt;'a&gt;</code>. We will reference this <code>request</code> variable later.</p>
<h2 id="using-async-fn-in-traits"><a class="header" href="#using-async-fn-in-traits">Using async fn in traits</a></h2>
<p>When you have <code>async fn</code> in a trait, you can use it with generic types in the usual way. For example, you could write a function that uses the above trait like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_request(
    mut provider: impl HttpRequestProvider,
    request: Request,
) {
    let response = provider.request(request).await;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Naturally you could also write the above example using explicit generics as well (just as with any impl trait):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_request&lt;P&gt;(
    mut provider: P,
    request: Request,
) where
    P: HttpRequestProvider,
{
    let response = provider.request(request).await;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="naming-the-future-that-is-returned"><a class="header" href="#naming-the-future-that-is-returned">Naming the future that is returned</a></h2>
<p>Like any function that returns an <code>impl Trait</code>, the return type from an <code>async fn</code> in a trait is anonymous. However, there are times when it can be very useful to be able to talk about it. One particular place where this comes up is when spawning tasks. Consider a function that invokes <code>process_request</code> (above) many times in parallel:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_all_requests&lt;P&gt;(
    provider: P,
    requests: Vec&lt;RequestData&gt;,
) where
    P: HttpRequestProvider + Clone + Send,
{
    let handles =
        requests
            .into_iter()
            .map(|r| {
                let provider = provider.clone();
                tokio::spawn(async move {
                    process_request(provider, r).await;
                })
            })
            .collect();
    join_all(handles).await;
}
<span class="boring">}
</span></code></pre></pre>
<p>As is, compiling this function gives the following error, even though <code>P</code> is marked as <code>Send</code>:</p>
<pre><code>error[E0277]: the future returned by `HttpRequestProvider::request` (invoked on `P`) cannot be sent between threads safely
   --&gt; src/lib.rs:21:17
    |
21  |                 tokio::spawn(async move {
    |                 ^^^^^^^^^^^^ `&lt;P as HttpRequestProvider&gt;::request` cannot be sent between threads safely
    |
note: future is not `Send` as it awaits another future which is not `Send`
   --&gt; src/lib.rs:35:5
    |
35  |     let response = provider.request(request).await?;
    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^ this future is not `Send`
note: required by a bound in `tokio::spawn`
   --&gt; /playground/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.13.0/src/task/spawn.rs:127:21
    |
127 |         T: Future + Send + 'static,
    |                     ^^^^ required by this bound in `tokio::spawn`
</code></pre>
<p>The problem here is that, while <code>P: Send</code>, the <em>future</em> returned by <code>request</code> is not necessarily <code>Send</code> (it could, for example, create <code>Rc</code> state and store it in local variables). To fix this, one can add the bound on the <code>P::request</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_all_requests&lt;P&gt;(
    provider: P,
    requests: Vec&lt;RequestData&gt;,
)
where
    P: HttpRequestProvider + Clone + Send,
    for&lt;'a&gt; P::request&lt;'a&gt;: Send,
{
    let handles =
        requests
            .into_iter()
            .map(|r| {
                let provider = provider.clone();
                your_runtime::spawn(async move {
                    process_request(provider, r).await;
                })
            })
            .collect();
    your_runtime::join_all(handles).await
}
<span class="boring">}
</span></code></pre></pre>
<p>The new bound is here:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    for&lt;'a&gt; P::request&lt;'a&gt;: Send,
<span class="boring">}
</span></code></pre></pre>
<p>The &quot;higher-ranked&quot; requirement says that &quot;no matter what lifetime <code>provider</code> has, the result is <code>Send</code>&quot;. Specifying these higher-ranked lifetimes can be a bit cumbersome, and sometimes the GATs accumulate quite a large number of parameters. Therefore, the compiler also supports a shorthand form; if you leave off the GAT parameters, the <code>for&lt;'a&gt;</code> is assumed:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>where
    P: HttpRequestProvider + Clone + Send,
    P::request: Send,
<span class="boring">}
</span></code></pre></pre>
<p>In fact, using a nightly feature, we can write this more compactly:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>where
    P: HttpRequestProvider&lt;request: Send&gt; + Clone + Send,
<span class="boring">}
</span></code></pre></pre>
<h3 id="when-would-send-bounds-be-required"><a class="header" href="#when-would-send-bounds-be-required">When would send bounds be required?</a></h3>
<p>One thing we are not sure of is how often send bounds would be required in practice. The main point where such bounds are required are for generic async functions that will be &quot;spawned&quot;. For example, the <code>process_request</code> function itself didn't require any kind of bounds on <code>request</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_request(
    mut provider: impl HttpRequestProvider,
    request: Request,
) {
    let response = provider.request(request).await;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is because nothing <em>in this function</em> was required to be <code>Send</code>. The problems only arise when you have a call to <code>spawn</code> or some other function that imposes a <code>Send</code> bound -- and even then, there may be no issue. For example, invoking <code>process_request</code> on a known type doesn't require any sort of where clauses:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>your_runtime::spawn(async move {
    process_request(MyProvider::new(), some_request);
})
<span class="boring">}
</span></code></pre></pre>
<p>This works because the compiler is able to see that <code>process_request</code> is being called with a <code>MyProvider</code>, and hence it can determine exactly what future <code>process_request</code> will call when it invokes <code>provider.request</code>, and it can see that this future is <code>Send</code>.</p>
<p>The problems only arise when you invoke <code>spawn</code> on a value of a generic type, like <code>P</code> in our example above. In that case, the compiler doesn't know exactly what future will run, so it needs some bounds on <code>P::request</code>.</p>
<h2 id="caveat-async-fn-in-trait-are-not-dyn-safe"><a class="header" href="#caveat-async-fn-in-trait-are-not-dyn-safe">Caveat: Async fn in trait are not dyn safe</a></h2>
<p>There is one key limitation in stage 1: <strong>traits that contain async fn are not dyn safe</strong>. Instead, support for dynamic dispatch is provided via a procedural macro called <code>#[dyner]</code>. In future stages, we expect to support dynamic dispatch &quot;natively&quot;, but we still need more experimentation and feedback on the requirements to find the best design.</p>
<p>The <code>#[dyner]</code> macro works as follows. You attach it to a trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[dyner]
trait HttpRequestProvider {
    async fn request(&amp;mut self, request: Request) -&gt; Response;
}
<span class="boring">}
</span></code></pre></pre>
<p>It will generate, alongside the trait, a type <code>DynHttpRequestProvider</code> (<code>Dyn</code> + the name of the trait, in general):</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Your trait, unchanged:
trait HttpRequestProvider { .. }

// A struct to represent a trait object:
struct DynHttpRequestProvider&lt;'me&gt; { .. }

impl&lt;'me&gt; HttpRequestProvider for DynHttpRequestProvider&lt;'me&gt;
{ .. }
<span class="boring">}
</span></code></pre></pre>
<p>This type is a replacement for <code>Box&lt;dyn HttpRequestProvider&gt;</code>. You can create an instance of it by writing <code>DynHttpRequestProvider::from(x)</code>, where <code>x</code> is of some type that implements <code>HttpRequestProvider</code>. The <code>DynHttpRequestProvider</code> implements <code>HttpRequestProvider</code> but it forwards each method through using dynamic dispatch.</p>
<h3 id="example-usage"><a class="header" href="#example-usage">Example usage</a></h3>
<p>Suppose we had a <code>Context</code> type that was generic over an <code>HttpRequestProvider</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context&lt;T: HttpRequestProvider&gt; {
   provider: T,
}

async fn process_request(
    provider: impl HttpRequestProvider,
    request: Request,
) -&gt; anyhow::Result&lt;()&gt; {
    let cx = Context {
        provider,
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Now suppose that we wanted to remove the <code>T</code> type parameter, so that <code>Context</code> included a trait object. You could do this with <code>dyner</code> by altering the code as follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context&lt;'me&gt; {
   provider: DynHttpRequestProvider&lt;'me&gt;,
}

async fn process_request(
    provider: impl HttpRequestProvider,
    request: Request,
) -&gt; anyhow::Result&lt;()&gt; {
    let cx = Context {
        provider: DynHttpRequestProvider::new(provider),
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You might be surprised to see the <code>'me</code> parameter -- this is needed because we don't whether the <code>provider</code> given to us includes borrowed data. If we knew that it had no references, we might also write:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context {
   provider: DynHttpRequestProvider&lt;'static&gt;,
}

async fn process_request(
    provider: impl HttpRequestProvider + 'static,
    request: Request,
) -&gt; anyhow::Result&lt;()&gt; {
    let cx = Context {
        provider: DynHttpRequestProvider::from(provider),
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dyner-with-references"><a class="header" href="#dyner-with-references">Dyner with references</a></h3>
<p>Dyner currently requires an allocator. The <code>DynHttpRequestProvider::new</code> method, for example, allocates a <code>Box</code> internally, and invoking an async function allocates a box to store the resulting future (the <code>#[async_trait]</code> crate does the same; the difference with this approach is that you only use the boxing when you are using dynamic dispatch).</p>
<p>Sometimes though we would like to construct our dynamic objects without using <code>Box</code>. This might be because we only have a <code>&amp;T</code> access or simply because we don't need to allocate and would prefer to avoid the runtime overhead. In cases like that, you can use the <code>from_ref</code> and <code>from_mut</code> methods. <code>from_ref</code> takes a <code>&amp;impl Trait</code> and gives you a <code>Ref&lt;DynTrait&gt;</code>; <code>Ref</code> is a special type that ensures you only use <code>&amp;self</code> methods. <code>from_mut</code> works the same way but for <code>&amp;mut Trait</code> types. Since the <code>provider</code> type never escapes <code>process_request</code>, we could rework our previous example to use mutable references instead of boxing:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Context&lt;'me&gt; {
   provider: &amp;'me mut DynHttpRequestProvider&lt;'me&gt;,
}

async fn process_request(
    mut provider: impl HttpRequestProvider,
    request: Request,
) -&gt; anyhow::Result&lt;()&gt; {
    let cx = Context {
        provider: DynHttpRequestProvider::from_mut(&amp;mut provider),
    };
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>The rest of the code would work just the same... you can still invoke methods in the usual way (e.g., <code>cx.provider.request(r).await</code>).</p>
<h3 id="dyner-and-no-std"><a class="header" href="#dyner-and-no-std">Dyner and no-std</a></h3>
<p>Because <code>dyner</code> requires an allocator, it is not currently suitable for no-std settings. We are exploring alternatives here: it's not clear if there is a suitable general purpose mechanism that could be used in settings like that. But part of the beauty of the dyner approach is that, in principle, there might be &quot;dyner-like&quot; crates that can be used in a no-std environment.</p>
<h3 id="dyner-all-the-things"><a class="header" href="#dyner-all-the-things">Dyner all the things</a></h3>
<p>Dyner is meant to be a &quot;general purpose&quot; replacement for <code>dyn Trait</code>. It expands the scope of what kinds of traits are dyn safe to include traits that use <code>impl Trait</code> in argument- and return-position. For example, the following trait is not dyn safe, but it is dyner safe:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[dyner]
trait Print {
    fn print(&amp;self, screen: &amp;mut impl Screen);
    //                           ^^^^^^^^^^^
    //                    impl trait is not dyn safe;
    //                    it is dyner-safe if the trait
    //                    is also procssed with dyner
}

#[dyner]
trait Screen {
    fn output(&amp;mut self, x: usize, y: usize, c: char);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="dyner-for-external-traits"><a class="header" href="#dyner-for-external-traits">Dyner for external traits</a></h3>
<p>For dyner to work well, all the traits that you reference from your dyner trait must be processed with dyner. But sometimes those traits may be out of your control! What can you do then? To support this, dyner permits you to apply dyner to an external trait definition. For example, support you had this trait, referencing the <a href="https://docs.rs/cc-traits/0.7.1/cc_traits/trait.Clear.html"><code>Clear</code> trait from <code>cc_traits</code></a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[dyner]
trait MyOp {
    fn apply_op(x: &amp;mut impl cc_traits::Clear);
}
<span class="boring">}
</span></code></pre></pre>
<p>Applying <code>dyner</code> to <code>MyOp</code> will yield an error that &quot;the type <code>cc_traits::DynClear</code> is not found&quot;. This is because the code that <code>dyner</code> generates expects that, for each <code>Foo</code> trait, there will be a <code>DynFoo</code> type available at the same location, and in this case there is not. You can fix this by using the <code>dyner::external_trait!</code> macro, but unfortunately doing so requires that you copy and paste the trait definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ext {
    dyner::external_trait! {
        pub trait cc_traits::Clear {
    	    fn clear(&amp;mut self);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>dyner::external_trait!</code> macro will generate two things:</p>
<ul>
<li>A re-export of <code>cc_traits::Clear</code></li>
<li>a type <code>DynClear</code></li>
</ul>
<p>Now we can rewrite our <code>MyOp</code> trait to reference <code>Clear</code> from this new location and everything works:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod ext { ... }

#[dyner]
trait MyOp {
    fn apply_op(x: &amp;mut impl ext::Clear);
    //                       ^^^ Changed this.
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>ext::Clear</code> path is just a re-exported version of <code>cc_traits::Clear</code>, so there is no change there, but the type <code>ext::DynClear</code> is well-defined.</p>
<h3 id="dyner-for-things-in-the-stdlib"><a class="header" href="#dyner-for-things-in-the-stdlib">Dyner for things in the stdlib</a></h3>
<p>The dyner crate already includes dyner-ified versions of things from the stdlib. However, to take advantage of them, you have to import the traits from <code>dyner::std</code>. For example, instead of referencing <code>std::iter::Iterator</code>, try <code>dyner::std::iter::Iterator</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dyner::std::iter::{Iterator, DynIterator};
//  ^^^^^^^                      ^^^^^^^^^^^

#[dyner]
trait WidgetStream {
    fn request(&amp;mut self, r: impl Iterator&lt;Item = String&gt;);
    //                            ^^^^^^^^ the macro will look for DynIterator
}
<span class="boring">}
</span></code></pre></pre>
<p>You can use <code>use dyner::std::prelude::*</code> to get all the same traits as are present in the std prelude, along with their <code>Dyn</code> equivalents.</p>
<h2 id="feedback-requested"><a class="header" href="#feedback-requested">Feedback requested</a></h2>
<p>We'd love to hear what you think. Nothing here is set in stone, quite far from it!</p>
<p>Some questions we are specifically interested in getting answers to:</p>
<ul>
<li>What about this document was confusing to you? We want you to understand, of course, but we also want to improve the way we explain things.</li>
<li>How often do you think you would use static vs dynamic dispatch in traits?</li>
<li>How are you managing async fn in trait today? Do you think the <code>dyner</code> crate would work for you?</li>
<li>How often do you think you use functions that require <code>Send</code>. Do you anticipate any problems from the bound scheme described above?</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../explainer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../explainer/phase_1_narrative.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../explainer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../explainer/phase_1_narrative.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
